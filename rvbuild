#!/usr/bin/perl
# vim: set ft=perl

use strict;
use warnings;

# FIXME: this is for debugging, should be remove after script is stable.
use Data::Dumper;
use Getopt::Long;

# Require perl-json module
# Arch Linux user can simply run:
#     sudo pacman -S perl-json
use JSON;

# setup the script
my $pkgname = "";
my $test_mode;
my $server = "";
my $rebuild_mode;
my $dry_run_mode;
my $rvpkgpath = $ENV{'RVPKGPATH'} // "~/riscv/packages";
my $rvpkgcache = $ENV{'RVPKGCACHE'} // "\$HOME/.cache/rvpkgcache";

# parse command line
GetOptions(
  "test|t" => \$test_mode,
  "server|s=s" => \$server,
  "rebuild|r" => \$rebuild_mode,
  "dry-run" => \$dry_run_mode,
);

# Trim the trailing white space or \n
sub trim_str {
  my $str = shift;
  $str =~ s/^\s+|\s+$//g;
  return $str;
}

# TODO: use span to describe a range of event
# Example:
#   my $logger = span->new("some log");
#   $logger->info("new event");
#
#   output:
#     => some log
#     ===> new event
#
#   my $logger = span->new("new span");
#   $logger->info("new event")
#   my $child = $logger->new("child span");
#   $child->error("child event")
#
#   $logger = span->new("another span");
#
#   output:
#     => new span
#     ===> new event
#     ===> child span
#     ======> child event
#     => another span
#
# my $ansi_green = "\e[0;32m";
# my $ansi_bold_red = "\e[1;31m";
# my $ansi_norm = "\e[0m";
# sub info {
#   print("$ansi_green=>$ansi_norm $_")
# }

# Test the ssh executable and get the exact path of the executable
my $ssh_exec = trim_str(`sh -c 'command -v ssh 2>&1'`);
if ($?) {
  die "No ssh executable found on this machine\n";
}

# We need rsync to download and upload files
my $rsync = trim_str(`sh -c 'command -v rsync 2>&1'`);
if ($?) {
  die "No rsync found on this server\n";
}

# Save server cache save the result to local disk.
sub save_server_cache {
  print("==> Saving server info......");
  open (my $server_cache, '>', '.ctx.json') or die 'fail to create .ctx.json file';
  my $server = shift;
  my %context = (
    'server' => $server,
    'ttimestamp' => time,
  );
  my $content = encode_json(\%context);
  print $server_cache "$content\n";
  close($server_cache);
  print("Done\n");
}

# Iterate a list of servers and get the server with lowest load.
# User can define available server by environment variable `$RVSERVERS`.
# User should use comma `,` to split the servers name.
#
# Example:
#   $ export $RVSERVERS "luxio,shinx,magmortar"
#
# Notice:
#   Please double check your environment variable is trailing with `S`.
#   It is `$RVSERVERS`, not `$RVSERVER`.
sub run_ssh_test {
  # find servers
  my @serverlist;

  # Get option from env
  if ($ENV{'RVSERVERS'}) {
    @serverlist = split(',', $ENV{RVSERVERS});
  } else {
    @serverlist = ('luxio', 'shinx', 'magmortar', 'minun', 'chimchar');
  }

  print "=> Testing servers...\n";
  # else we try to find the server with lowest load
  my $min = 0.00;
  my $server = "";

  foreach my $pending (@serverlist) {
    print "====> Task: test $pending......";

    # use the 15min load
    my $cmd = "$ssh_exec $pending uptime | awk '{print \$12}'";
    my $current_load = `$cmd` or die "Fail to run command $cmd";

    if ($min == 0.00 || $current_load < $min) {
      $min = $current_load;
      $server = $pending;
    }

    print "Done\n";
  }

  return $server;
}

# Read from `.ctx.json` file. Return empty string if the script fail
# to read the file for some reason.
sub read_context {
  open(my $ctx_fd, '<:encoding(UTF-8)', '.ctx.json') or return "";
  local $/;
  return <$ctx_fd>;
}

# Return the the appropriate server for the jobs.
# There are 3 ways to defined the target server.
#
# # The strategies:
#
# 1. get server by argument --server or -s
#   User can specify the target server by arguments --server or -s.
#   For example: rvbuild --server shinx, then all the jobs will be run
#   on shinx server only.
#
# 2. get server from cache
#   After running the machine load test, the script will buffer the
#   result and store it into the `.ctx.json` file. If the file exist
#   and the duration between last buffered time and current time is
#   under 30 minutes, the script will use that buffered server.
#
# 3. get the lowest load server from list of servers
#   If there is no argument, no cache file or the cache is outdated,
#   the script will try to run command `uptime | awk '{ print $12 }'`
#   to get the load from each server.
sub select_host {
  my $server = "";

  if ($dry_run_mode) {
    return "Monk Server";
  }

  # get buffer
  my $ctx = read_context();
  # if the file exist
  if ($ctx ne "") {
    my $ctx_json = decode_json($ctx);
    my $duration = time - $ctx_json->{'ttimestamp'};
    # and the duration is under 30 minutes
    if ($duration < 1800) {
      return $ctx_json->{'server'};
    }
  }

  # test server
  $server = run_ssh_test();
  save_server_cache($server);
  return $server;
}

# Mkdir the path for PKGBUILD and cache, then run the asp update command
sub prepare {
  my $prefix = "$ssh_exec $server";

  if ($dry_run_mode) {
    print("=> PKGBUILD file path: $rvpkgpath\n");
    print("=> Build cache path: $rvpkgcache\n");
    print("=> Using command: $prefix to build\n");
    return;
  }

  # If we are rebuilding stuff, send the local PKGBUILD to remote if it
  # exist.
  if ($rebuild_mode) {
    # the -f test if the file exist and is a plain text file
    if (-f "PKGBUILD") {
      system("$rsync -azhP PKGBUILD $server:$rvpkgpath/$pkgname/trunk/") == 0
        or die "Fail to send local PKGBUILD back to server";
    }
  }

  # Get the remote path for packages
  print("==> Package will be checkout into $rvpkgpath\n");
  system("$prefix 'mkdir -p $rvpkgpath'") == 0
    or die "Fail to create dir <$rvpkgpath> on server <$server>";

  # Get the remote cache path for packages
  print("==> Build cache will be saved into $rvpkgcache\n");
  system("$prefix 'mkdir -p $rvpkgcache'") == 0
    or die "Fail to create dir <$rvpkgcache> on server <$server>";

  print("==> Running asp update\n");
  system("$prefix 'asp update'") == 0
    or die "fail to execute asp update, is the asp exist on <$server>?";
}

sub checkout {
  my $pkgname = shift;

  my $prefix = "$ssh_exec $server";

  if ($dry_run_mode) {
    print("=> Using command: $prefix to build\n");
    print("=> asp checkout $pkgname\n");
    return;
  }

  # FIXME: fish will not accpet `()` since fish use it to execute command. So it is better to
  # use `sh -c` here to avoid some fish "features" mess up our workspace.
  print("==> Checking out package: $pkgname to $rvpkgpath\n");

  # asp checkout will only be run when the path is not exist on target machine
  if (system("$prefix 'test -d $rvpkgpath/$pkgname'") == 0) {
    return;
  }

  system("$prefix 'cd $rvpkgpath && asp checkout $pkgname'") == 0
    or die "fail to get $pkgname 's PKGBUILD file";

  print("==> Setting PKGBUILD architecture to \"riscv64\"\n");
  system("$prefix 'cd $rvpkgpath/$pkgname/trunk && setconf PKGBUILD arch \'(\"riscv64\")\''") == 0
    or die "fail to set arch for $pkgname";
}

sub build {
  my $pkgname = shift;

  my $prefix = "$ssh_exec $server";

  # FIXME: is it better to use script template instead of execute script one by one?

  print("==> Starting build\n");
  my $rvbuild_cmd = "extra-riscv64-build -- -d \"$rvpkgcache:/var/cache/pacman/pkg/\"";

  if ($dry_run_mode) {
    print("=> Using command: $rvbuild_cmd to build\n");
    return;
  }

  my $build_fail = 0;
  system("$prefix 'cd $rvpkgpath/$pkgname/trunk && $rvbuild_cmd'") == 0
    or $build_fail = 1;

  if ($build_fail == 0) {
    print "==> Build process for $pkgname is success\n";
    return;
  }

  print "==> Fail to build $pkgname, start downloading files...\n";

  # the -f test if the file exist and is a plain text file
  if (-f "PKGBUILD") {
    print "There is a PKGBUILD already exist in the local, do you want to cover it? [y/N]";
    my $confirm = <STDIN>;
    chomp $confirm;
    if ($confirm ne "y") {
      print "==> Nothing to do\n";
      return;
    }
  }
  system("$rsync -azvhP $server:$rvpkgpath/$pkgname/trunk/PKGBUILD .") == 0
    or die "Fail to fetch PKGBUILD from target server";
}

# Test mode only test load on servers
if ($test_mode) {
  print "Lowest load server: ", select_host(), "\n";
  exit 0;
}

# If no pkgname is given, and it is not in test mode,
# the script just exit with error code.
if ((scalar @ARGV) == 0) {
  print "No package name given, exit...\n";
  exit 1;
} else {
  # FIXME: user may want to pass list of pacakge to build, the script is
  # responsible to handle this and use different user to build those pkg.
  $pkgname = join('', @ARGV);
}

# If no server is given by option --server, the script we try
# to get it itself.
if ($server eq "") {
  $server = select_host() or die 'fail to select host server';
}

print "=> Using server: $server\n";
print "=> Preparing to build package: $pkgname\n";
prepare();

print "=> Fetching PKGBUILD for $pkgname\n";
checkout($pkgname) if (!$rebuild_mode);

print "=> Start building $pkgname\n";
build($pkgname);
