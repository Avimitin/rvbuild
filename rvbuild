#!/usr/bin/perl
# vim: set ft=perl

=pod
Some concept about this script:

=head1 1. How to select the server

First user needs to define a list of available SSH server.
Then this script will iterate the list and find the server with loadest load,
and set it as the main operating server.

This process will be buffered. The script will create a `.ctx.json` file.
And write the server name and the test time into it.

  {
    'server': 'shinx',
    'ttimestamp': 0,
  }

Since most packagers are working in the same UTC, so the buffer will be kept
with only 30 minutes. This can be a configurable value.

=head2 2. How to run a build

This script will concate command line string to behave a build.
A build is separate into 4 stages.

=head3 2.1 Prepare

The script will first create directory on the build server.
It will manage all packages inside one directory.
By default it will create a `$HOME/riscv/packages` directory under the
home directory. And all the PKGBUILD file will be checked out inside it.

Then it will create a cache directory for the package file.
It will be `$HOME/.cache/rvpkgcache/` by default.

You can configured the path by setting the environment variable `$RVPKGPATH`
and `$RVPKGCACHE`.

=head3 2.2 Build

Run this script by command:

  rvbuild <pkgname>

The script will first try to find if this package is already exist in the
`RVPKGPATH` directory.

If it is exist, it will cd into the package directory and run the build.

If not, the pkgname will be concated into the asp command:

  asp update && asp checkout <pkgname>

Then the script will cd into the checkouted directory and run the below command.

  extra-riscv64-build -- -d "$RVPKGCACHE:/var/cache/pacman/pkg/"

=head3 2.3 Fix

If the build is not exit successfully, the script will try to use rsync to
download PKGBUILD and source directory. This files will be placed in the
same directory as the script with the below directory structure.

=item script

=item src/<pkgname>/

=item PKGBUILD

When you run the `rvbuild <pkgname>` again, the script will know that their
is a PKGBUILD stay with it, it will send the local PKGBUILD to the remote
server and run the build again.

The script will not handle the source, it is responsible for packager to
handle it.

=head3 2.4 Done

When you run command `rvbuild done`, the script will clean up the local directory.

=cut


use strict;
use warnings;

# FIXME: this is for debugging, should be remove after script is stable.
use Data::Dumper;
use Getopt::Long;

# Require perl-json module
# Arch Linux user can simply run:
#     sudo pacman -S perl-json
use JSON;

# Trim the trailing white space or \n
sub trim_str {
  my $str = shift;
  $str =~ s/^\s+|\s+$//g;
  return $str;
}

# TODO: use span to describe a range of event
# Example:
#   my $logger = span->new("some log");
#   $logger->info("new event");
#
#   output:
#     => some log
#     ===> new event
#
#   my $logger = span->new("new span");
#   $logger->info("new event")
#   my $child = $logger->new("child span");
#   $child->error("child event")
#
#   $logger = span->new("another span");
#
#   output:
#     => new span
#     ===> new event
#     ===> child span
#     ======> child event
#     => another span
#
# my $ansi_green = "\e[0;32m";
# my $ansi_bold_red = "\e[1;31m";
# my $ansi_norm = "\e[0m";
# sub info {
#   print("$ansi_green=>$ansi_norm $_")
# }

# Test the ssh executable and get the exact path of the executable
my $ssh_exec = trim_str(`sh -c 'command -v ssh 2>&1'`);
if ($?) {
  die "No ssh executable found on this machine\n";
}

# We need rsync to download and upload files
my $rsync = trim_str(`sh -c 'command -v rsync 2>&1'`);
if ($?) {
  die "No rsync found on this server\n";
}

# Save server cache save the result to local disk.
sub save_server_cache {
  print("==> Saving server info......");
  open (my $server_cache, '>', '.ctx.json') or die 'fail to create .ctx.json file';
  my $server = shift;
  my %context = (
    'server' => $server,
    'ttimestamp' => time,
  );
  my $content = encode_json(\%context);
  print $server_cache "$content\n";
  close($server_cache);
  print("Done\n");
}

# Iterate a list of servers and get the server with lowest load.
# User can define available server by environment variable `$RVSERVERS`.
# User should use comma `,` to split the servers name.
#
# Example:
#   $ export $RVSERVERS "luxio,shinx,magmortar"
#
# Notice:
#   Please double check your environment variable is trailing with `S`.
#   It is `$RVSERVERS`, not `$RVSERVER`.
sub run_ssh_test {
  # find servers
  my @serverlist;

  # Get option from env
  if ($ENV{'RVSERVERS'}) {
    @serverlist = split(',', $ENV{RVSERVERS});
  } else {
    @serverlist = ('luxio', 'shinx', 'magmortar', 'minun', 'chimchar');
  }

  print "=> Testing servers...\n";
  # else we try to find the server with lowest load
  my $min = 0.00;
  my $server = "";

  foreach my $pending (@serverlist) {
    print "====> Task: test $pending......";

    # use the 15min load
    my $cmd = "$ssh_exec $pending uptime | awk '{print \$12}'";
    my $current_load = `$cmd` or die "Fail to run command $cmd";

    if ($min == 0.00 || $current_load < $min) {
      $min = $current_load;
      $server = $pending;
    }

    print "Done\n";
  }

  return $server;
}

# Read from `.ctx.json` file. Return empty string if the script fail
# to read the file for some reason.
sub read_context {
  open(my $ctx_fd, '<:encoding(UTF-8)', '.ctx.json') or return "";
  local $/;
  return <$ctx_fd>;
}

# Return the the appropriate server for the jobs.
# There are 3 ways to defined the target server.
#
# # The strategies:
#
# 1. get server by argument --server or -s
#   User can specify the target server by arguments --server or -s.
#   For example: rvbuild --server shinx, then all the jobs will be run
#   on shinx server only.
#
# 2. get server from cache
#   After running the machine load test, the script will buffer the
#   result and store it into the `.ctx.json` file. If the file exist
#   and the duration between last buffered time and current time is
#   under 30 minutes, the script will use that buffered server.
#
# 3. get the lowest load server from list of servers
#   If there is no argument, no cache file or the cache is outdated,
#   the script will try to run command `uptime | awk '{ print $12 }'`
#   to get the load from each server.
sub select_host {
  my $server = "";

  # get buffer
  my $ctx = read_context();
  # if the file exist
  if ($ctx ne "") {
    my $ctx_json = decode_json($ctx);
    my $duration = time - $ctx_json->{'ttimestamp'};
    # and the duration is under 30 minutes
    if ($duration < 1800) {
      return $ctx_json->{'server'};
    }
  }

  # test server
  $server = run_ssh_test();
  save_server_cache($server);
  return $server;
}

sub prepare_and_build {
  my $server = shift;
  my $pkgname = shift;

  my $prefix = "$ssh_exec $server";

  # FIXME: is it better to use script template instead of execute script one by one?

  # Get the remote path for packages
  my $rvpkgpath = $ENV{'RVPKGPATH'} // "~/riscv/packages";
  print("==> Package will be checkout into $rvpkgpath\n");
  system("$prefix 'mkdir -p $rvpkgpath'") == 0
    or die "Fail to create dir <$rvpkgpath> on server <$server>";

  # Get the remote cache path for packages
  my $rvpkgcache = $ENV{'RVPKGCACHE'} // "\$HOME/.cache/rvpkgcache";
  print("==> Build cache will be saved into $rvpkgcache\n");
  system("$prefix 'mkdir -p $rvpkgcache'") == 0
    or die "Fail to create dir <$rvpkgcache> on server <$server>";

  print("==> Running asp update\n");
  system("$prefix 'asp update'") == 0
    or die "fail to execute asp update, is the asp exist on <$server>?";

  # TODO: Do not fetch PKGBUILD when the path is exist.

  print("==> Checking out package: $pkgname to $rvpkgpath\n");
  system("$prefix 'cd $rvpkgpath && asp checkout $pkgname'") == 0
    or die "fail to get $pkgname 's PKGBUILD file";

  print("==> Setting PKGBUILD architecture to \"riscv64\"\n");
  system("$prefix 'cd $rvpkgpath/$pkgname/trunk && setconf PKGBUILD arch \\(\"riscv64\"\\)'") == 0
    or die "fail to set arch for $pkgname";

  print("==> Starting build\n");
  my $rvbuild_cmd = "extra-riscv64-build -- -d \"$rvpkgcache:/var/cache/pacman/pkg/\"";
  my $build_fail = 0;
  system("$prefix 'cd $rvpkgpath/$pkgname/trunk && $rvbuild_cmd'") == 0
    or $build_fail = 1;

  if ($build_fail == 0) {
    print "==> Build process for $pkgname is success\n";
    return;
  }

  print "==> Fail to build $pkgname, start downloading files...\n";
  system("$rsync -azvhP $server:$rvpkgpath/$pkgname/trunk/PKGBUILD .") == 0
    or die "Fail to fetch PKGBUILD from target server";
}

# setup the script
my $pkgname = "";
my $test_mode;
my $server = "";

# parse command line
GetOptions(
  "test|t" => \$test_mode,
  "server|s=s" => \$server,
);

# Test mode only test load on servers
if ($test_mode) {
  print "Lowest load server: ", select_host(), "\n";
  exit 0;
}

# If no pkgname is given, and it is not in test mode,
# the script just exit with error code.
if ((scalar @ARGV) == 0) {
  print "No package name given, exit...\n";
  exit 1;
} else {
  # FIXME: user may want to pass list of pacakge to build, the script is
  # responsible to handle this and use different user to build those pkg.
  $pkgname = join('', @ARGV);
}

# If no server is given by option --server, the script we try
# to get it itself.
if ($server eq "") {
  $server = select_host() or die 'fail to select host server';
}

print "=> Using server: $server\n";
print "=> Preparing to build package: $pkgname\n";
prepare_and_build($server, $pkgname);
