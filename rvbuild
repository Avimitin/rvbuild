#!/usr/bin/perl
# vim: set ft=perl
############################### pp
# Some concept about this script:
#
#
# 1. How to select the server
# ===========================
#
#   First user needs to define a list of available SSH server.
#   Then this script will iterate the list and find the server with loadest load,
#   and set it as the main operating server.
#
#   This process will be buffered. The script will create a `.ctx.json` file.
#   And write the server name and the test time into it.
#
#       Server: shinx
#       Date: <cache date>
#
#   Since most packagers are working in the same UTC, so the buffer will be kept
#   with only 30 minutes. This can be a configurable value.
#
#
# 2. How to run a build
# =====================
#
#   This script will concate command line string to behave a build.
#   A build is separate into 4 stages.
#
#
#   2.1 Prepare
#   -----------
#   The script will first create directory on the build server.
#   It will manage all packages inside one directory.
#   By default it will create a `$HOME/riscv/packages` directory under the
#   home directory. And all the PKGBUILD file will be checked out inside it.
#
#   Then it will create a cache directory for the package file.
#   It will be `$HOME/.cache/rvpkgcache/` by default.
#
#   You can configured the path by setting the environment variable `$RVPKGPATH`
#   and `$RVPKGCACHE`.
#
#
#   2.2 Build
#   ---------
#   Run this script by command:
#
#       rvbuild <pkgname>
#
#   The script will first try to find if this package is already exist in the
#   `RVPKGPATH` directory.
#
#   If it is exist, it will cd into the package directory and run the build.
#
#   If not, the pkgname will be concated into the asp command:
#
#       asp update && asp checkout <pkgname>
#
#   Then the script will cd into the checkouted directory and run the below command.
#
#       extra-riscv64-build -- -d "$RVPKGCACHE:/var/cache/pacman/pkg/"
#
#
#   2.3 Fix
#   -------
#   If the build is not exit successfully, the script will try to use rsync to
#   download PKGBUILD and source directory. This files will be placed in the
#   same directory as the script with the below directory structure.
#
#       * script
#       * src/<pkgname>/
#       * PKGBUILD
#
#   When you run the `rvbuild <pkgname>` again, the script will know that their
#   is a PKGBUILD stay with it, it will send the local PKGBUILD to the remote
#   server and run the build again.
#
#   The script will not handle the source, it is responsible for packager to
#   handle it.
#
#
#   2.4 Done
#   --------
#   When you run command `rvbuild done`, the script will clean up the local directory.


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

# Require perl-json module
# Arch Linux user can simply run:
#     sudo pacman -S perl-json
use JSON;

# get the remote path for packages
my $rvpkgpath = $ENV{'RVPKGPATH'} // "$ENV{'HOME'}/riscv/packages";

# get the remote cache path for packages
my $rvpkgcache = $ENV{'RVPKGCACHE'} // "$ENV{'HOME'}/.cache/rvpkgcache";

# trim the trailing white space or \n
sub trim_str {
  my $str = shift;
  $str =~ s/^\s+|\s+$//g;
  return $str;
}

# test the ssh executable and get the exact path of the executable
my $ssh_exec = `sh -c 'command -v ssh 2>&1'`;
if ($?) {
  die "No ssh executable found on this machine\n";
}

$ssh_exec = trim_str($ssh_exec);

# find servers
my @serverlist;
if ($ENV{'RVSERVERS'}) {
  # try to parse string like "server1,server2,server3"
  @serverlist = split(',', $ENV{RVSERVERS});
} else {
  @serverlist = ('luxio', 'shinx', 'magmortar', 'minun', 'chimchar');
}

# get the available server
sub select_host {
  my $server = "";
  # get options by pattern --server or -s
  GetOptions('server|s=s' => \$server);

  # if user specify the server name, just use it
  if ($server) {
    return $server;
  };

  # TODO: if there is a local buffer indicate the server name
  # if (open(my $ctx_fd, '<', '.ctx.json')) {
  #   my $json = JSON->new->utf8;
  #   my $content = <$ctx_fd>;
  #   my %server = $json->decode_json($content);
  # };

  print "=> Testing servers...\n";
  # else we try to find the server with lowest load
  my $min = 0.00;
  QUERY:
  foreach my $pending (@serverlist) {
    print "====> Task: test $pending......";

    # use the 15min load
    my $cmd = "$ssh_exec $pending uptime | awk '{print \$12}'";
    my $current_load = `$cmd` or die "Fail to run command $cmd";
    if ($min == 0.00 || $current_load < $min) {
      $min = $current_load;
      $server = $pending;
    }

    print "Done\n";
  }

  return $server;
}

sub save_server_cache {
  print("==> Saving server info......");
  open (SERVER_LOAD_CACHE, '>', '.ctx.json') or die 'fail to create .ctx.json file';
  my $json = JSON->new->utf8;
  my $server = shift;
  my $now = `date +'%Y-%m-%d-%H-%M-%S'`;
  my %context = (
    'server' => $server,
    'date' => trim_str($now),
  );
  my $content = $json->encode(\%context);
  print SERVER_LOAD_CACHE "$content\n";
  close(SERVER_LOAD_CACHE);
  print("Done\n");
}

my $server = select_host() or die 'fail to select host server';
save_server_cache($server);
print "\n";

